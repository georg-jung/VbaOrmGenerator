// ------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion: 16.0.0.0
//  
//     Änderungen an dieser Datei können fehlerhaftes Verhalten verursachen und gehen verloren, wenn
//     der Code neu generiert wird.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace OrmGenerator.Vba.T4
{
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using System;
    
    /// <summary>
    /// Class to produce the template output
    /// </summary>
    
    #line 1 "C:\Users\georg\source\repos\VbaOrmGenerator\OrmGenerator.Vba\T4\OrmAdodb.tt"
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class OrmAdodb : OrmAdodbBase
    {
#line hidden
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            this.Write("VERSION 1.0 CLASS\r\nBEGIN\r\n  MultiUse = -1  \'True\r\nEND\r\nAttribute VB_Name = \"OrmAd" +
                    "odb\"\r\nAttribute VB_GlobalNameSpace = False\r\nAttribute VB_Creatable = False\r\nAttr" +
                    "ibute VB_PredeclaredId = False\r\nAttribute VB_Exposed = False\r\n\'@Description(\"An " +
                    "object-relational mapper to map between DAO tables and VBA class objects.\")\r\n\'@F" +
                    "older(\"ORM\")\r\nOption Explicit\r\n\r\nImplements IMapper\r\n\r\nPrivate Const mlngErrorNu" +
                    "mber As Long = vbObjectError + 513\r\nPrivate Const mstrClassName As String = \"Orm" +
                    "Adodb\"\r\n\r\nPrivate Enum WriteOption\r\n    Insert\r\n    Update\r\nEnd Enum\r\n\r\n\r\n\' ====" +
                    "=========================================================================\r\n\' PUB" +
                    "LIC METHODS\r\n\' =================================================================" +
                    "============\r\n\r\n\'@Description(\"Deletes all objects of the provided IMappable typ" +
                    "e from the data store.\")\r\n\'@Param(\"obj: An IMappable of the type to be deleted.\"" +
                    ")\r\n\'@Returns(\"The number of records deleted from the data store.\")\r\nPublic Funct" +
                    "ion DeleteAll(ByVal obj As IMappable) As Long\r\n    DeleteAll = IMapper_DeleteAll" +
                    "(obj)\r\nEnd Function\r\n\r\n\'@Description(\"Deletes a collection of IMappable objects " +
                    "from the data store.\")\r\n\'@Param(\"col: A collection of IMappable objects to be de" +
                    "leted.\"\r\n\'@Returns(\"The number of records deleted.\")\r\nPublic Function DeleteMult" +
                    "iple(ByVal col As Collection) As Long\r\n    DeleteMultiple = IMapper_DeleteMultip" +
                    "le(col)\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Deletes a single IMappable object from" +
                    " the data store.\")\r\n\'@Param(\"obj: An IMappable object to be deleted.\")\r\nPublic S" +
                    "ub DeleteSingle(ByVal obj As IMappable)\r\n    IMapper_DeleteSingle obj\r\nEnd Sub\r\n" +
                    "\r\n\r\n\'@Description(\"Maps records from the data store to a collection of IMappable" +
                    " objects.\")\r\n\'@Param(\"obj: A concrete IMappable instance of the type to which th" +
                    "e records will be mapped.\")\r\n\'@Returns(\"A collection of mapped objects.\")\r\nPubli" +
                    "c Function GetAll(ByVal obj As IMappable) As Collection\r\n    Set GetAll = IMappe" +
                    "r_GetAll(obj)\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Maps a recordset retrieved by th" +
                    "e provided query to a collection of IMappable objects.\")\r\n\'@Param(\"obj: A concre" +
                    "te IMappable instance of the type to which the records will be mapped.\")\r\n\'@Para" +
                    "m(\"strQuery: A SQL query defining the result set.\")\r\n\'@Returns(\"A collection of " +
                    "mapped objects.\")\r\nPublic Function GetMultiple(ByVal obj As IMappable, ByVal str" +
                    "Query As String) As Collection\r\n    Set GetMultiple = IMapper_GetMultiple(obj, s" +
                    "trQuery)\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Maps a recordset retrieved by the pro" +
                    "vided filter criteria to a collection of IMappable objects.\")\r\n\'@Param(\"obj: A c" +
                    "oncrete IMappable instance of the type to which the records will be mapped.\")\r\n\'" +
                    "@Returns(\"A collection of mapped objects.\")\r\nPublic Function GetMultipleByFilter" +
                    "(ByVal obj As IMappable, ByVal strFilterCriteria As String) As Collection\r\n    S" +
                    "et GetMultipleByFilter = IMapper_GetMultipleByFilter(obj, strFilterCriteria)\r\nEn" +
                    "d Function\r\n\r\n    \r\n\'@Description(\"Maps the values of a single record to an IMap" +
                    "pable object passed by reference.\")\r\n\'@Param(\"obj: A concrete IMappable instance" +
                    " of the type to which the records will be mapped.\")\r\n\'@Param(\"vntPrimaryKey: The" +
                    " record\'s primary key.\")\r\n\'@Returns(\"A value indicating whether the retrieval wa" +
                    "s successful.\")\r\n\'@Remarks(\"This procedure changes the values of the object pass" +
                    "ed by reference.\")\r\nPublic Function GetSingle(ByRef obj As IMappable, ByVal vntP" +
                    "rimaryKey As Variant) As Boolean\r\n    GetSingle = IMapper_GetSingle(obj, vntPrim" +
                    "aryKey)\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Inserts a collection of IMappable obje" +
                    "cts into the data store.\")\r\n\'@Param(\"col: A collection of IMappable objects to b" +
                    "e inserted into the data store.\")\r\n\'@Remarks(\"Primary keys autogenerated by the " +
                    "insert operation are assigned to the object by reference.\")\r\nPublic Sub InsertMu" +
                    "ltiple(ByRef col As Collection)\r\n    IMapper_InsertMultiple col\r\nEnd Sub\r\n\r\n\r\n\'@" +
                    "Description(\"Inserts an IMappable instance into the data store.\")\r\n\'@Param(\"obj:" +
                    " An IMappable object to be inserted into the data store.\")\r\n\'@Remarks(\"Primary k" +
                    "eys autogenerated by the insert operation are assigned to the object by referenc" +
                    "e.\")\r\nPublic Sub InsertSingle(ByRef obj As IMappable)\r\n    IMapper_InsertSingle " +
                    "obj\r\nEnd Sub\r\n\r\n    \r\n\'@Description(\"Determines if the provided item exists in t" +
                    "he data store.\")\r\n\'@Param(\"The IMappable object to be tested.\")\r\n\'@Returns(\"A va" +
                    "lue indicating whether the provided item exists in the data store.\")\r\nPublic Fun" +
                    "ction ItemExists(ByVal obj As IMappable) As Boolean\r\n    ItemExists = IMapper_It" +
                    "emExists(obj)\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Updates the data store record as" +
                    "sociated with each IMappable object in the provided collection.\")\r\n\'@Param(\"col:" +
                    " A collection of IMappable objects to be updated.\")\r\nPublic Sub UpdateMultiple(B" +
                    "yVal col As Collection)\r\n    IMapper_UpdateMultiple col\r\nEnd Sub\r\n\r\n\r\n\'@Descript" +
                    "ion(\"Updates the data store record associated with the provided IMappable object" +
                    ".\")\r\n\'@Param(\"obj: An IMappable object to be updated.\")\r\nPublic Sub UpdateSingle" +
                    "(ByVal obj As IMappable)\r\n    IMapper_UpdateSingle obj\r\nEnd Sub\r\n\r\n\r\n\'@Descripti" +
                    "on(\"Upserts a collection of IMappable objects into the data store.\")\r\n\'@Param(\"c" +
                    "ol: A collection of IMappable objects to be upserted.\")\r\nPublic Sub UpsertMultip" +
                    "le(ByVal col As Collection)\r\n    IMapper_UpsertMultiple col\r\nEnd Sub\r\n\r\n    \r\n\'@" +
                    "Description(\"Upserts an IMappable object into the data store.\")\r\n\'@Param(\"obj: A" +
                    "n IMappable object to be upserted.\")\r\nPublic Sub UpsertSingle(ByVal obj As IMapp" +
                    "able)\r\n    IMapper_UpsertSingle obj\r\nEnd Sub\r\n\r\n\r\n\' ============================" +
                    "=================================================\r\n\' PRIVATE METHODS\r\n\' ========" +
                    "=====================================================================\r\n\r\n\'@Descr" +
                    "iption(\"Determines whether the provided field in the provided table autoincremen" +
                    "ts.\")\r\n\'@Param(\"The table name in which the field resides.\")\r\n\'@Param(\"The field" +
                    " to be tested.\")\r\n\'@Returns(\"A value indicating whether the provided field autoi" +
                    "ncrements.\")\r\nPrivate Function FieldAutoIncrements(ByVal strTableName As String," +
                    " ByVal strFieldName As String) As Boolean\r\n\r\nDim conn As ADODB.connection\r\nDim r" +
                    "ec As ADODB.Recordset\r\nDim fld As ADODB.Field\r\n\r\n    Set conn = GetOpenConnectio" +
                    "n()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open strTableName, conn\r\n\r\n    S" +
                    "et fld = rec.Fields(strFieldName)\r\n    \r\n    FieldAutoIncrements = fld.Propertie" +
                    "s(\"IsAutoIncrement\").Value\r\n\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Retrieves the dic" +
                    "tionary key that corresponds to the provided item.\")\r\n\'@Param(\"objDictionary: Th" +
                    "e dictionary containing the key-value pair.\")\r\n\'@Param(\"vntItem: A dictionary it" +
                    "em..\")\r\n\'@Returns(\"A dictionary key value.\")\r\nPrivate Function GetKeyFromItem(By" +
                    "Val objDictionary As Object, ByVal vntItem As Variant) As Variant\r\nDim vntKey As" +
                    " Variant\r\n    For Each vntKey In objDictionary.Keys\r\n        If objDictionary.It" +
                    "em(vntKey) = vntItem Then\r\n            GetKeyFromItem = vntKey\r\n            Exit" +
                    " Function\r\n        End If\r\n    Next vntKey\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Det" +
                    "ermines the primary key field set on the table.\")\r\n\'@Param(\"strTableName: The na" +
                    "me of the table from which to retrieve the primary key field.\")\r\n\'@Returns(\"The " +
                    "name of the primary key field.\")\r\nPrivate Function GetPrimaryKeyFieldName(ByVal " +
                    "strTableName As String) As String\r\n\r\nDim conn As ADODB.connection\r\nDim rec As AD" +
                    "ODB.Recordset\r\n\r\n    Set conn = GetOpenConnection()\r\n    Set rec = conn.OpenSche" +
                    "ma(adSchemaPrimaryKeys, Array(Empty, Empty, strTableName))\r\n   \r\n    GetPrimaryK" +
                    "eyFieldName = rec.Fields(\"COLUMN_NAME\")\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Maps a" +
                    "n IMappable object to a new record in the provided recordset.\")\r\n\'@Param(\"rec: T" +
                    "he recordset where the object will be mapped.\")\r\n\'@Param(\"obj: An instance of th" +
                    "e IMappable type to be mapped.\")\r\n\'@Param(\"intWriteOption: An enumerated value i" +
                    "ndicating the write option (insert or update) for the operation.\"\r\n\'@Param(\"strP" +
                    "rimaryKeyFieldName: The name of the recordset\'s primary key field.\")\r\n\'@Param(\"b" +
                    "lnPrimaryKeyAutoIncrements: A value indicating whether the primary key field aut" +
                    "oincrements.\")\r\n\'@Remarks(\"This procedure changes the values of the object passe" +
                    "d by reference.\")\r\nPrivate Sub MapObjectToRecord(ByRef rec As ADODB.Recordset, B" +
                    "yRef obj As IMappable, ByVal intWriteOption As WriteOption, ByVal strPrimaryKeyF" +
                    "ieldName As String, ByVal blnPrimaryKeyAutoIncrements As Boolean)\r\n    \r\nDim str" +
                    "PrimaryKeyClassProperty As String\r\nDim vntProperty As Variant\r\nDim strClassPrope" +
                    "rty As String\r\nDim strTableProperty As String\r\n\r\n    If intWriteOption = WriteOp" +
                    "tion.Insert Then\r\n        rec.AddNew\r\n    ElseIf intWriteOption = WriteOption.Up" +
                    "date Then\r\n        rec.Update\r\n    End If\r\n    \r\n    For Each vntProperty In obj" +
                    ".MappedProperties\r\n        \r\n        strClassProperty = CStr(vntProperty)\r\n     " +
                    "   strTableProperty = obj.MappedProperties.Item(vntProperty)\r\n        \r\n        " +
                    "If strTableProperty = strPrimaryKeyFieldName Then\r\n            strPrimaryKeyClas" +
                    "sProperty = strClassProperty\r\n            \r\n            If Not blnPrimaryKeyAuto" +
                    "Increments Then\r\n                rec.Fields(strTableProperty).Value = obj.GetPro" +
                    "pertyValue(strClassProperty)\r\n            End If\r\n        Else\r\n            rec." +
                    "Fields(strTableProperty).Value = obj.GetPropertyValue(strClassProperty)\r\n       " +
                    " End If\r\n        \r\n    Next vntProperty\r\n    \r\n    \' this does not work with sql" +
                    " server\r\n    \'obj.LetPropertyValue strPrimaryKeyClassProperty, rec.Fields(strPri" +
                    "maryKeyFieldName).Value\r\n    rec.Update\r\n    \r\nEnd Sub\r\n\r\n\r\n\'@Description(\"Maps " +
                    "the current recordset record to an IMappable objects.\")\r\n\'@Param(\"rec: The recor" +
                    "dset containing the current record to be mapped.\")\r\n\'@Param(\"obj: An instance of" +
                    " the IMappable type to be mapped.\")\r\n\'@Remarks(\"This procedure changes the value" +
                    "s of the object passed by reference.\")\r\nPrivate Sub MapRecordToObject(ByRef rec " +
                    "As ADODB.Recordset, ByRef obj As IMappable)\r\n    \r\nDim vntProperty As Variant\r\nD" +
                    "im strClassProperty As String\r\nDim strTableProperty As String\r\n\r\n    For Each vn" +
                    "tProperty In obj.MappedProperties\r\n        \r\n        strClassProperty = CStr(vnt" +
                    "Property)\r\n        strTableProperty = obj.MappedProperties.Item(vntProperty)\r\n  " +
                    "      \r\n        If Not IsNull(rec.Fields(strTableProperty).Value) Then\r\n        " +
                    "    obj.LetPropertyValue strClassProperty, rec.Fields(strTableProperty).Value\r\n " +
                    "       End If\r\n        \r\n    Next vntProperty\r\n\r\nEnd Sub\r\n\r\n\r\n\'@Description(\"Map" +
                    "s the provided recordset to a collection of IMappable objects.\")\r\n\'@Param(\"rec: " +
                    "The recordset to be mapped.\")\r\n\'@Param(\"obj: A concrete instance of the IMappabl" +
                    "e type to be mapped.\")\r\n\'@Returns(\"A collection of IMappable objects.\")\r\nPrivate" +
                    " Function MapRecordsetToCollection(ByVal rec As ADODB.Recordset, ByVal obj As IM" +
                    "appable) As Collection\r\n\r\nDim objToAdd As IMappable\r\nDim col As Collection\r\n\r\n  " +
                    "  Set col = New Collection\r\n    Do While Not rec.BOF And Not rec.EOF\r\n        Se" +
                    "t objToAdd = obj.CreateNew\r\n        MapRecordToObject rec, objToAdd\r\n        col" +
                    ".Add objToAdd\r\n        rec.MoveNext\r\n    Loop\r\n    \r\n    Set MapRecordsetToColle" +
                    "ction = col\r\n    \r\nEnd Function\r\n\r\n\r\n\'@Description(\"Converts a value to an SQL-f" +
                    "riendly string.\")\r\n\'@Param(\"The value to be parsed.\")\r\n\'@Returns(\"An SQL-friendl" +
                    "y string representation of the value.\")\r\nPrivate Function ParseSqlCriteria(ByVal" +
                    " vntCriteria As Variant) As String\r\n\r\n    If IsDate(vntCriteria) Then\r\n        P" +
                    "arseSqlCriteria = \"#\" & CDate(vntCriteria) & \"#\"\r\n        \r\n    ElseIf IsNumeric" +
                    "(vntCriteria) Then\r\n        ParseSqlCriteria = CStr(vntCriteria)\r\n        \r\n    " +
                    "Else\r\n        ParseSqlCriteria = \"\'\" & CStr(vntCriteria) & \"\'\"\r\n    \r\n    End If" +
                    "\r\n\r\nEnd Function\r\n\r\n\r\n\'@Description(\"Wraps field and table names containing spac" +
                    "es with brackets.\")\r\n\'@Param(\"The field or table name to wrap.\")\r\n\'@Returns(\"A q" +
                    "uery-safe field or table name.\")\r\nPrivate Function WrapUnsafeNames(ByVal strName" +
                    " As String) As String\r\n    If InStr(1, strName, \" \", vbTextCompare) > 0 Then\r\n  " +
                    "      WrapUnsafeNames = \"[\" & strName & \"]\"\r\n    Else\r\n        WrapUnsafeNames =" +
                    " strName\r\n    End If\r\nEnd Function\r\n\r\n\r\n\' ======================================" +
                    "=======================================\r\n\' INTERFACE IMPLEMENTATION\r\n\' =========" +
                    "====================================================================\r\n\r\nPrivate " +
                    "Function IMapper_DeleteAll(ByVal obj As IMappable) As Long\r\n\r\nDim conn As ADODB." +
                    "connection\r\nDim strQuery As String\r\n\r\n    Set conn = GetOpenConnection()\r\n    st" +
                    "rQuery = \"DELETE * FROM \" & WrapUnsafeNames(obj.TableName) & \";\"\r\n    conn.Execu" +
                    "te strQuery, IMapper_DeleteAll\r\n    \r\nEnd Function\r\n\r\n\r\nPrivate Function IMapper" +
                    "_DeleteMultiple(ByVal col As Collection) As Long\r\n\r\nDim strPrimaryKeyFieldName A" +
                    "s String\r\nDim strPrimaryKeyRecordName As String\r\nDim vntItem As Variant\r\nDim obj" +
                    "Item As IMappable\r\nDim strPrimaryKeys As String\r\nDim strQuery As String\r\n\r\nDim c" +
                    "onn As ADODB.connection\r\n\r\n    If col.Count = 0 Then\r\n        Exit Function\r\n   " +
                    " End If\r\n    \r\n    Set objItem = col.Item(1)\r\n    strPrimaryKeyFieldName = GetPr" +
                    "imaryKeyFieldName(objItem.TableName)\r\n    strPrimaryKeyRecordName = CStr(GetKeyF" +
                    "romItem(objItem.MappedProperties, strPrimaryKeyFieldName))\r\n    \r\n    For Each v" +
                    "ntItem In col\r\n        Set objItem = vntItem\r\n        strPrimaryKeys = strPrimar" +
                    "yKeys & ParseSqlCriteria(CStr(objItem.GetPropertyValue(strPrimaryKeyRecordName))" +
                    ") & \",\"\r\n    Next vntItem\r\n    \r\n    strQuery = \"DELETE * FROM \" & WrapUnsafeNam" +
                    "es(objItem.TableName) & \" WHERE \" & WrapUnsafeNames(strPrimaryKeyFieldName) & \" " +
                    "IN (\" & strPrimaryKeys & \");\"\r\n    \r\n    Set conn = GetOpenConnection()\r\n    con" +
                    "n.Execute strQuery, IMapper_DeleteMultiple\r\n\r\nEnd Function\r\n\r\n\r\nPrivate Sub IMap" +
                    "per_DeleteSingle(ByVal obj As IMappable)\r\n\r\nDim strPrimaryKeyFieldName As String" +
                    "\r\nDim strPrimaryKeyRecordName As String\r\nDim strPrimaryKey As String\r\n\r\nDim conn" +
                    " As ADODB.connection\r\nDim rec As ADODB.Recordset\r\n\r\nConst strProcedureName As St" +
                    "ring = \"DeleteSingle\"\r\n    \r\n    strPrimaryKeyFieldName = GetPrimaryKeyFieldName" +
                    "(obj.TableName)\r\n    strPrimaryKeyRecordName = CStr(GetKeyFromItem(obj.MappedPro" +
                    "perties, strPrimaryKeyFieldName))\r\n    strPrimaryKey = ParseSqlCriteria(CStr(obj" +
                    ".GetPropertyValue(strPrimaryKeyRecordName)))\r\n    \r\n    Set conn = GetOpenConnec" +
                    "tion()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableName, conn, adO" +
                    "penDynamic, adLockOptimistic\r\n    rec.Filter = strPrimaryKeyFieldName & \" = \" & " +
                    "strPrimaryKey\r\n    \r\n    With rec\r\n        \r\n        If .RecordCount > 1 Then\r\n " +
                    "           Err.Raise mlngErrorNumber, mstrClassName & \".\" & strProcedureName, \"M" +
                    "ore than one result found.\"\r\n        End If\r\n        \r\n        .Delete\r\n        " +
                    "\r\n    End With\r\n\r\nEnd Sub\r\n\r\n\r\nPrivate Function IMapper_GetAll(ByVal obj As IMap" +
                    "pable) As Collection\r\n\r\nDim conn As ADODB.connection\r\nDim rec As ADODB.Recordset" +
                    "\r\n\r\n    Set conn = GetOpenConnection()\r\n    Set rec = New ADODB.Recordset\r\n    r" +
                    "ec.Open obj.TableName, conn\r\n    Set IMapper_GetAll = MapRecordsetToCollection(r" +
                    "ec, obj)\r\n\r\nEnd Function\r\n\r\n\r\nPrivate Function IMapper_GetMultiple(ByVal obj As " +
                    "IMappable, ByVal strQuery As String) As Collection\r\n\r\nDim conn As ADODB.connecti" +
                    "on\r\nDim rec As ADODB.Recordset\r\n    \r\n    Set conn = GetOpenConnection()\r\n    Se" +
                    "t rec = New ADODB.Recordset\r\n    rec.Open strQuery, conn\r\n    Set IMapper_GetMul" +
                    "tiple = MapRecordsetToCollection(rec, obj)\r\n\r\nEnd Function\r\n\r\n\r\nPublic Function " +
                    "IMapper_GetMultipleByFilter(ByVal obj As IMappable, ByVal strFilterCriteria As S" +
                    "tring) As Collection\r\n\r\nDim conn As ADODB.connection\r\nDim rec As ADODB.Recordset" +
                    "\r\n    \r\n    Set conn = GetOpenConnection()\r\n    Set rec = New ADODB.Recordset\r\n " +
                    "   rec.Open obj.TableName, conn\r\n    rec.Filter = strFilterCriteria\r\n    Set IMa" +
                    "pper_GetMultipleByFilter = MapRecordsetToCollection(rec, obj)\r\n    \r\nEnd Functio" +
                    "n\r\n\r\n\r\nPrivate Function IMapper_GetSingle(ByRef obj As IMappable, ByVal vntPrima" +
                    "ryKey As Variant) As Boolean\r\n\r\nDim strPrimaryKeyFieldName As String\r\nDim strPri" +
                    "maryKey As String\r\nDim strQuery As String\r\n\r\nDim vntProperty As Variant\r\nDim str" +
                    "ClassProperty As String\r\nDim strTableProperty As String\r\n\r\nDim conn As ADODB.con" +
                    "nection\r\nDim rec As ADODB.Recordset\r\n\r\nConst strProcedureName As String = \"GetSi" +
                    "ngleByPrimaryKey\"\r\n   \r\n    strPrimaryKeyFieldName = GetPrimaryKeyFieldName(obj." +
                    "TableName)\r\n    strPrimaryKey = ParseSqlCriteria(vntPrimaryKey)\r\n    strQuery = " +
                    "\"SELECT * FROM \" & WrapUnsafeNames(obj.TableName) & \" WHERE \" & WrapUnsafeNames(" +
                    "strPrimaryKeyFieldName) & \" = \" & strPrimaryKey & \";\"\r\n       \r\n    Set conn = G" +
                    "etOpenConnection()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableNam" +
                    "e, conn\r\n    \r\n    With rec\r\n    \r\n        If .RecordCount = 0 Then\r\n           " +
                    " IMapper_GetSingle = False\r\n            Exit Function\r\n        End If\r\n        \r" +
                    "\n        If .RecordCount > 1 Then\r\n            IMapper_GetSingle = False\r\n      " +
                    "      Err.Raise mlngErrorNumber, mstrClassName & \".\" & strProcedureName, \"More t" +
                    "han one result found.\"\r\n        End If\r\n        \r\n        MapRecordToObject rec," +
                    " obj\r\n        \r\n    End With\r\n   \r\n    IMapper_GetSingle = True\r\n\r\nEnd Function\r" +
                    "\n\r\n\r\nPrivate Sub IMapper_InsertSingle(ByRef obj As IMappable)\r\n\r\nDim strPrimaryK" +
                    "eyFieldName As String\r\nDim blnPrimaryKeyAutoIncrements As Boolean\r\nDim conn As A" +
                    "DODB.connection\r\nDim rec As ADODB.Recordset\r\n\r\n    strPrimaryKeyFieldName = GetP" +
                    "rimaryKeyFieldName(obj.TableName)\r\n    blnPrimaryKeyAutoIncrements = FieldAutoIn" +
                    "crements(obj.TableName, strPrimaryKeyFieldName)\r\n   \r\n    Set conn = GetOpenConn" +
                    "ection()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableName, conn, a" +
                    "dOpenDynamic, adLockOptimistic\r\n    MapObjectToRecord rec, obj, WriteOption.Inse" +
                    "rt, strPrimaryKeyFieldName, blnPrimaryKeyAutoIncrements\r\n    \r\nEnd Sub\r\n\r\n\r\nPriv" +
                    "ate Sub IMapper_InsertMultiple(ByRef col As Collection)\r\n\r\nDim strPrimaryKeyClas" +
                    "sProperty As String\r\nDim strPrimaryKeyFieldName As String\r\nDim blnPrimaryKeyAuto" +
                    "Increments As Boolean\r\n\r\nDim conn As ADODB.connection\r\nDim rec As ADODB.Recordse" +
                    "t\r\n\r\nDim vntItem As Variant\r\nDim objItem As IMappable\r\nDim vntProperty As Varian" +
                    "t\r\nDim strClassProperty As String\r\nDim strTableProperty As String\r\n\r\n    If col." +
                    "Count = 0 Then\r\n        Exit Sub\r\n    End If\r\n\r\n    Set objItem = col.Item(1)\r\n " +
                    "   strPrimaryKeyFieldName = GetPrimaryKeyFieldName(objItem.TableName)\r\n    blnPr" +
                    "imaryKeyAutoIncrements = FieldAutoIncrements(objItem.TableName, strPrimaryKeyFie" +
                    "ldName)\r\n    \r\n    Set conn = GetOpenConnection()\r\n    Set rec = New ADODB.Recor" +
                    "dset\r\n    rec.Open objItem.TableName, conn, adOpenDynamic, adLockOptimistic\r\n   " +
                    "    \r\n    For Each vntItem In col\r\n        Set objItem = vntItem\r\n        MapObj" +
                    "ectToRecord rec, objItem, WriteOption.Insert, strPrimaryKeyFieldName, blnPrimary" +
                    "KeyAutoIncrements\r\n    Next vntItem\r\n\r\nEnd Sub\r\n\r\n\r\nPrivate Function IMapper_Ite" +
                    "mExists(ByVal obj As IMappable) As Boolean\r\n\r\nDim strPrimaryKeyFieldName As Stri" +
                    "ng\r\nDim strPrimaryKeyRecordName As String\r\nDim strPrimaryKey As String\r\nDim strQ" +
                    "uery As String\r\n\r\nDim conn As ADODB.connection\r\nDim rec As ADODB.Recordset\r\n\r\n  " +
                    "  strPrimaryKeyFieldName = GetPrimaryKeyFieldName(obj.TableName)\r\n    strPrimary" +
                    "KeyRecordName = CStr(GetKeyFromItem(obj.MappedProperties, strPrimaryKeyFieldName" +
                    "))\r\n    strPrimaryKey = ParseSqlCriteria(CStr(obj.GetPropertyValue(strPrimaryKey" +
                    "RecordName)))\r\n    strQuery = \"SELECT \" & WrapUnsafeNames(strPrimaryKeyFieldName" +
                    ") & \" FROM \" & WrapUnsafeNames(obj.TableName) & \" WHERE \" & WrapUnsafeNames(strP" +
                    "rimaryKeyFieldName) & \" = \" & strPrimaryKey & \";\"\r\n    \r\n    Set conn = GetOpenC" +
                    "onnection()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableName, conn" +
                    "\r\n\r\n    IMapper_ItemExists = rec.RecordCount > 0\r\n\r\nEnd Function\r\n\r\n\r\nPrivate Su" +
                    "b IMapper_UpdateMultiple(ByVal col As Collection)\r\n\r\nDim strPrimaryKeyFieldName " +
                    "As String\r\nDim strPrimaryKeyRecordName As String\r\nDim blnPrimaryKeyAutoIncrement" +
                    "s As Boolean\r\nDim strQuery As String\r\n\r\nDim conn As ADODB.connection\r\nDim rec As" +
                    " ADODB.Recordset\r\n\r\nDim vntItem As Variant\r\nDim objItem As IMappable\r\n\r\nDim vntP" +
                    "roperty As Variant\r\nDim strClassProperty As String\r\nDim strTableProperty As Stri" +
                    "ng\r\nDim strPrimaryKeyValue As String\r\n\r\nConst strProcedureName As String = \"Upda" +
                    "teMultiple\"\r\n\r\n    If col.Count = 0 Then\r\n        Exit Sub\r\n    End If\r\n\r\n    Se" +
                    "t objItem = col.Item(1)\r\n    strPrimaryKeyFieldName = GetPrimaryKeyFieldName(obj" +
                    "Item.TableName)\r\n    strPrimaryKeyRecordName = CStr(GetKeyFromItem(objItem.Mappe" +
                    "dProperties, strPrimaryKeyFieldName))\r\n    blnPrimaryKeyAutoIncrements = FieldAu" +
                    "toIncrements(objItem.TableName, strPrimaryKeyFieldName)\r\n    \r\n    Set conn = Ge" +
                    "tOpenConnection()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open objItem.Table" +
                    "Name, conn, adOpenDynamic, adLockOptimistic\r\n    \r\n    With rec\r\n        \r\n     " +
                    "   For Each vntItem In col\r\n            Set objItem = vntItem\r\n            \r\n   " +
                    "         .Filter = strPrimaryKeyFieldName & \"=\" & ParseSqlCriteria(objItem.GetPr" +
                    "opertyValue(strPrimaryKeyRecordName))\r\n\r\n            If .RecordCount = 0 Then\r\n " +
                    "               Err.Raise mlngErrorNumber, mstrClassName & \".\" & strProcedureName" +
                    ", \"Item not found in the data store.\"\r\n            End If\r\n            \r\n       " +
                    "     MapObjectToRecord rec, objItem, WriteOption.Update, strPrimaryKeyFieldName," +
                    " blnPrimaryKeyAutoIncrements\r\n            \r\n        Next vntItem\r\n        \r\n    " +
                    "End With\r\n\r\nEnd Sub\r\n\r\n\r\nPrivate Sub IMapper_UpdateSingle(ByVal obj As IMappable" +
                    ")\r\n\r\nDim strPrimaryKeyFieldName As String\r\nDim strPrimaryKeyRecordName As String" +
                    "\r\nDim blnPrimaryKeyAutoIncrements As Boolean\r\n\r\nDim conn As ADODB.connection\r\nDi" +
                    "m rec As ADODB.Recordset\r\n\r\nDim vntProperty As Variant\r\nDim strClassProperty As " +
                    "String\r\nDim strTableProperty As String\r\n\r\nConst strProcedureName As String = \"Up" +
                    "dateSingle\"\r\n\r\n    strPrimaryKeyFieldName = GetPrimaryKeyFieldName(obj.TableName" +
                    ")\r\n    strPrimaryKeyRecordName = CStr(GetKeyFromItem(obj.MappedProperties, strPr" +
                    "imaryKeyFieldName))\r\n    blnPrimaryKeyAutoIncrements = FieldAutoIncrements(obj.T" +
                    "ableName, strPrimaryKeyFieldName)\r\n    \r\n    Set conn = GetOpenConnection()\r\n   " +
                    " Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableName, conn, adOpenDynamic," +
                    " adLockOptimistic\r\n    rec.Filter = strPrimaryKeyFieldName & \" = \" & obj.GetProp" +
                    "ertyValue(strPrimaryKeyRecordName)\r\n    \r\n    With rec\r\n        \r\n        If .Re" +
                    "cordCount = 0 Then\r\n            Err.Raise mlngErrorNumber, mstrClassName & \".\" &" +
                    " strProcedureName, \"Item not found in the data store.\"\r\n        End If\r\n        " +
                    "\r\n        If .RecordCount > 1 Then\r\n            Err.Raise mlngErrorNumber, mstrC" +
                    "lassName & \".\" & strProcedureName, \"More than one possible record match found in" +
                    " the data store.\"\r\n        End If\r\n        \r\n        MapObjectToRecord rec, obj," +
                    " WriteOption.Update, strPrimaryKeyFieldName, blnPrimaryKeyAutoIncrements\r\n      " +
                    "  \r\n    End With\r\n\r\nEnd Sub\r\n\r\n\r\nPublic Sub IMapper_UpsertMultiple(ByVal col As " +
                    "Collection)\r\n\r\nDim strPrimaryKeyFieldName As String\r\nDim strPrimaryKeyRecordName" +
                    " As String\r\nDim blnPrimaryKeyAutoIncrements As Boolean\r\nDim blnItemExists As Boo" +
                    "lean\r\nDim conn As ADODB.connection\r\nDim rec As ADODB.Recordset\r\nDim vntItem As V" +
                    "ariant\r\nDim objItem As IMappable\r\n\r\n    If col.Count = 0 Then\r\n        Exit Sub\r" +
                    "\n    End If\r\n    \r\n    Set objItem = col.Item(1)\r\n    strPrimaryKeyFieldName = G" +
                    "etPrimaryKeyFieldName(objItem.TableName)\r\n    strPrimaryKeyRecordName = CStr(Get" +
                    "KeyFromItem(objItem.MappedProperties, strPrimaryKeyFieldName))\r\n    blnPrimaryKe" +
                    "yAutoIncrements = FieldAutoIncrements(objItem.TableName, strPrimaryKeyFieldName)" +
                    "\r\n    \r\n    Set conn = GetOpenConnection()\r\n    Set rec = New ADODB.Recordset\r\n " +
                    "   rec.Open objItem.TableName, conn, adOpenDynamic, adLockOptimistic\r\n    \r\n    " +
                    "For Each vntItem In col\r\n        Set objItem = vntItem\r\n        \r\n            re" +
                    "c.Filter = strPrimaryKeyFieldName & \"=\" & ParseSqlCriteria(objItem.GetPropertyVa" +
                    "lue(strPrimaryKeyRecordName))\r\n            \r\n            If rec.BOF And rec.EOF " +
                    "Then\r\n                MapObjectToRecord rec, objItem, WriteOption.Insert, strPri" +
                    "maryKeyFieldName, blnPrimaryKeyAutoIncrements\r\n            Else\r\n               " +
                    " MapObjectToRecord rec, objItem, WriteOption.Update, strPrimaryKeyFieldName, bln" +
                    "PrimaryKeyAutoIncrements\r\n            End If\r\n                    \r\n    Next vnt" +
                    "Item\r\n    \r\nEnd Sub\r\n\r\n\r\nPublic Sub IMapper_UpsertSingle(ByVal obj As IMappable)" +
                    "\r\n    \r\nDim strPrimaryKeyFieldName As String\r\nDim strPrimaryKeyRecordName As Str" +
                    "ing\r\nDim blnPrimaryKeyAutoIncrements As Boolean\r\nDim conn As ADODB.connection\r\nD" +
                    "im rec As ADODB.Recordset\r\n\r\n    strPrimaryKeyFieldName = GetPrimaryKeyFieldName" +
                    "(obj.TableName)\r\n    strPrimaryKeyRecordName = CStr(GetKeyFromItem(obj.MappedPro" +
                    "perties, strPrimaryKeyFieldName))\r\n    blnPrimaryKeyAutoIncrements = FieldAutoIn" +
                    "crements(obj.TableName, strPrimaryKeyFieldName)\r\n    \r\n    Set conn = GetOpenCon" +
                    "nection()\r\n    Set rec = New ADODB.Recordset\r\n    rec.Open obj.TableName, conn, " +
                    "adOpenDynamic, adLockOptimistic\r\n    \r\n    rec.Filter = strPrimaryKeyFieldName &" +
                    " \"=\" & ParseSqlCriteria(obj.GetPropertyValue(strPrimaryKeyRecordName))\r\n    If r" +
                    "ec.BOF And rec.EOF Then\r\n        MapObjectToRecord rec, obj, WriteOption.Insert," +
                    " strPrimaryKeyFieldName, blnPrimaryKeyAutoIncrements\r\n    Else\r\n        MapObjec" +
                    "tToRecord rec, obj, WriteOption.Update, strPrimaryKeyFieldName, blnPrimaryKeyAut" +
                    "oIncrements\r\n    End If\r\n    \r\nEnd Sub\r\n");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
    #region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public class OrmAdodbBase
    {
        #region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
        #endregion
        #region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set
            {
                this.generationEnvironmentField = value;
            }
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent
        {
            get
            {
                return this.currentIndentField;
            }
        }
        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get
            {
                return this.sessionField;
            }
            set
            {
                this.sessionField = value;
            }
        }
        #endregion
        #region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
            error.ErrorText = message;
            error.IsWarning = true;
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
        #endregion
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
    }
    #endregion
}
